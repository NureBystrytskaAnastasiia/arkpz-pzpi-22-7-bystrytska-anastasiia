// ===================== Основні рекомендації написання коду для мови програмування TypeScript=====================

// Рекомендація 1: Основи стилю коду
// Пояснення: Дотримуйтесь чистоти та зрозумілості коду. Використовуйте зрозумілі назви функцій і змінних, уникання непотрібного коду та дотримуйтесь консистентного форматування.
// Це полегшує розуміння коду та його підтримку.

function calculateAdjustedValue(value: number): number { 
  // Використовуємо зрозумілу назву функції
  if (value > 0) { 
    return value + 10; // Збільшуємо значення на 10
  } else {
    return value - 10; // Зменшуємо значення на 10
  }
}

let totalPrice: number = 100;  // Початкова сума  
let discountRate: number = 0.1;  // ставка знижки 10%

// ===================== Коментарі =====================

// Рекомендація 2: Коментарі
// Пояснення: Коментарі повинні пояснювати мету та логіку, а не просто повторювати код.
  
// Поганий приклад:
let discount = 0.1;  // знижка
totalPrice = totalPrice * discount;  // застосування знижки

/* Гарний приклад:
Зменшуємо totalPrice на 10% для застосування знижки:
множимо суму на (1 - ставка знижки)
*/
totalPrice = totalPrice * (1 - discountRate);
console.log(totalPrice);  // Виведення результату

// ===================== Іменування =====================

// Рекомендація 3: Іменування
// Пояснення: Використовуйте зрозумілі та інтуїтивні назви змінних та функцій. Імена повинні чітко вказувати на їх призначення.

// Поганий приклад:
let u: string; // "u" не дає зрозумілої інформації
let a: number = 30; // "a" не пояснює значення

// Гарний приклад:
let userName: string;  // Зрозуміле іменування для змінної з ім'ям користувача
let maxAttempts: number = 30;  // Ім'я змінної вказує на максимальну кількість спроб

// ===================== Документування коду =====================

// Рекомендація 4: Документування коду
// Пояснення: Документуйте функціональність за допомогою JSDoc, щоб пояснити параметри та очікувані результати.

// Поганий приклад:
// let total = price + tax;  // Застосовуємо податок

// Гарний приклад:
 /**
 * Функція для обчислення загальної суми з урахуванням податку.
 * @param price - початкова ціна товару
 * @param tax - ставка податку
 * @returns загальна сума після застосування податку
 */
function calculateTotal(price: number, tax: number): number {
  return price + tax;  // Обчислюємо загальну суму з податком
}

// ===================== Конвенція =====================

// Рекомендація 5: Конвенція
// Пояснення: Дотримуйтесь чіткої структури та іменування функцій і змінних для покращення зручності читання коду.

// Поганий приклад:
function add(a: number, b: number): number {  // Параметри з типами
  return a + b;
}
let total1: number = add(5, 10);
console.log(total1);

// Гарний приклад:
function addNumbers(a: number, b: number): number {  // Уникнення повторного імені функції
  return a + b;
}
let total2: number = addNumbers(5, 10);
console.log(total2);

// ===================== TDD (Тестування через розробку) =====================

// Рекомендація 6: TDD (Тестування через розробку)
// Пояснення: Починайте з написання тестів перед реалізацією функцій, щоб забезпечити високу якість коду.

// Поганий приклад: Тестування відсутнє, функція не перевірена
function sum(a: number, b: number): number {
  return a + b;  // Якщо є помилка, її складно буде знайти
}
console.log(sum(5, 10));

// Гарний приклад: Розробка через тестування
// Спочатку пишемо тест
function testSum() {
  const result = sum(5, 10);
  if (result !== 15) {
    throw new Error(`Expected 15, but got ${result}`);
  }
  console.log('Test passed!');
}

// Потім реалізуємо функцію
function sum(a: number, b: number): number {
  return a + b;
}

// Запускаємо тест
testSum();

// ===================== Обробка помилок =====================

// Рекомендація 7: Обробка помилок
// Пояснення: Використовуйте блоки try-catch для обробки помилок. Це робить код більш надійним і передбачуваним.

// Поганий приклад: Відсутня обробка помилок
function parseJSONBad(jsonString: string): any {
  const data = JSON.parse(jsonString); // Помилка тут зупинить виконання програми
  return data;
}

try {
  console.log(parseJSONBad('{"key": "value"')); // Невірний JSON
} catch {
  console.log("Цей код виконається тільки через try/catch в іншій частині програми.");
}

// Гарний приклад: Використання try/catch для обробки помилок
function parseJSONGood(jsonString: string): any {
  try {
    const data = JSON.parse(jsonString);
    return data; // Повернення оброблених даних
  } catch (error) {
    console.error("Помилка парсингу JSON:", error); // Логування помилки
    return null; // Повернення безпечного значення
  }
}

const result = parseJSONGood('{"key": "value"'); // Невірний JSON
if (result === null) {
  console.log("Не вдалося обробити JSON, виконуються альтернативні дії.");
} else {
  console.log("Успішний результат:", result);
}

// ===================== ООП (Об'єктно-орієнтоване програмування) =====================

// Рекомендація 8: ООП
// Пояснення: Використовуйте класи і інкапсуляцію для створення гнучких і розширюваних рішень.

// Поганий приклад:
class User {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

let user = new User("John", 30);
console.log(user);

// Гарний приклад:
class User {
  constructor(public name: string, private age: number) {}

  getAge(): number {
    return this.age;
  }
}

let user = new User("John", 30);
console.log(user.getAge());

// ===================== Функціональне програмування =====================

// Рекомендація 9: Функціональне програмування
// Пояснення: Використовуйте чисті функції та незмінні дані для створення легкого та ефективного коду.

// Поганий приклад: Використання змінюваних змінних
let numbers = [1, 2, 3, 4, 5];
let doubledNumbers = [];
for (let i = 0; i < numbers.length; i++) {
  doubledNumbers.push(numbers[i] * 2);
}
console.log(doubledNumbers); // [2, 4, 6, 8, 10]

// Гарний приклад: Використання чистих функцій та незмінюваних даних
const nums = [1, 2, 3, 4, 5];
const doubledNums = nums.map(n => n * 2);
console.log(doubledNums); // [2, 4, 6, 8, 10]
